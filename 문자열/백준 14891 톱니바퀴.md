# 백준 #14891 톱니바퀴
`골드5` `문자열` `구현`
---
- 톱니바퀴의 회전을 무엇으로 구현하느냐가 첫번째 고민이었는데, 상대적으로 삽입 삭제가 쉬운 문자열로 입력받아서 처리 하고자 함.
- 기준이 되는 톱니바퀴의 좌측과 우측의 톱니바퀴들 모두를 검사해서 각각마다 이전 회전과 다른 방향으로 회전했다.
- 시간과 메모리에 대해서 관대한 문제 같아서 문제에서 요구하는 그대로 구현만 해도 통과 가능해보임.

### 전체코드
```jsx
string gear[4]; //톱니바퀴 정보
int rotateCnt; //회전수
vector<pair<int, int>>v; //회전할 바퀴, 방향
int answer = 0;

void rotate(int idx, int dir) {
	if (dir == 1) { //시계방향일 떄
		string c = gear[idx].substr(7); //맨 끝 문자
		gear[idx].erase(7);//지움
		gear[idx].insert(0, c); //맨 앞에 끝문자 추가
	}
	else {//반시계방향일 때
		string c = gear[idx].substr(0, 1); //맨 앞문자
		gear[idx].erase(0, 1);//지움
		gear[idx] += c; //맨 뒤에 앞문자 추가
	}
}

int main()
{
  //톱니바퀴정보, 회전수 입력
	for (int i = 0; i < 4; i++)
		cin >> gear[i];
	cin >> rotateCnt;

	//회전 바퀴와 방향 입력
	for (int i = 0; i < rotateCnt; i++) {
		int n, d;
		cin >> n >> d;
		v.push_back({ n,d });
	}
  
  //톱니 회전
	for (int i = 0; i < v.size(); i++) {
		int ngear = v[i].first -1; //기준 바퀴
		int dir = v[i].second; //방향
		int left = -1; //기준바퀴를 기준으로 왼쪽 몇 번째까지 회전하는지
		int right = -1;
		for (int j = ngear-1; j >= 0; j--) { //기준 왼쪽 톱니들 탐색
			if (gear[j + 1][6] != gear[j][2]) {
				left = j;
			}
			else
				break;
		}
		for (int j = ngear + 1; j < 4; j++) { //기준 오른쪽 톱니들 탐색
			if (gear[j - 1][2] != gear[j][6]) {
				right = j;
			}
			else
				break;
		}
		int ddir = -1;
		if(left != -1)
		for (int j = ngear-1; j >= left; j--) //기어 왼쪽 톱니 회전
		{
			rotate(j, dir * ddir); //이전 회전의 반대로 회전
			ddir *= -1;
		}
		ddir = -1;
		if(right != -1)
		for (int j = ngear+1; j <= right; j++) //기어 오른쪽 톱니 회전
		{
			rotate(j, dir * ddir);
			ddir *= -1;
		}
		rotate(ngear, dir);
	}

	for (int i = 0; i < 4; i++)
		if (gear[i][0] == '1') //맨 위 톱니가 1일 때 
			answer += pow(2, i);
	cout << answer;
}
```
