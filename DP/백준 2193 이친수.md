# 백준 #2193 [이친수](https://www.acmicpc.net/problem/2193)
`실버3` `DP`
---
- 처음에 어떻게 풀어야 할지 되게 혼란했는데, 하나 씩 만들어보니 패턴이 있었다.
- 이전 자릿수의 숫자들에서 맨 뒷 자리가 0이면 다음 자릿수에서 0과 1을 붙여서 생성하고, 맨 뒷 자리가 1이면 0을 붙여서 생성하면 됨.
- 2차원 배열을 선언해서 자릿수의 총 수와 0의 개수를 함께 저장함.

### 전체코드
```jsx
int main()
{
	int N;
	long long DP[91][2]; //i자릿수 이친수의 수, 0의 수

	cin >> N;
	DP[1][0] = 1; DP[1][1] = 0; //1의 자리는 1하나로, 개수는 1개, 0의 개수는 0개
	DP[2][0] = 1; DP[2][1] = 1; //두자릿수는 10하나로, 개수는 1개, 0의 개수는 1개
	for (int i = 2; i <= N; i++) {
		DP[i][0] = DP[i - 1][0] + DP[i - 1][1]; //총 개수는 이전 자릿수의 총 개수 + 0의 개수
		DP[i][1] = DP[i - 1][0]; //0의 개수는 이전 자리의 총 개수
	}
	cout << DP[N][0] << endl; //N의 자리의 총 개수 출력
}
```
