# unique함수
- 중복되는 항목을 맨 뒤로 보낸다.
`unique(시작, 끝)`
```jsx
vector<int>v;
unique(v.begin(), v.end());
```
만약 v[6]={1,3,3,4,4,5}이라면
**unique(v.begin(), v.end())** 의 결과는 v[6]={1,3,4,5,3,4} 이고 (중복을 제거한 후 나머지를 맨 뒤로 보내서 보존하는데 나왔던 순서대로 뒤로 보냄)
리턴 값은 나머지를 맨 뒤로 보내기 시작한 값의 iterator를 가리킨다. 이 예시에서는 3,4가 맨 뒤로 보내진 값들이고, 그 중 첫번째인 3을 가리키는 4가 리턴된다.

# erase함수
- 배열이나 벡터내에서 시작부터 끝까지 지운다
`erase(시작, 끝)` 
```jsx
vector<int>v(original); //original 이라는 벡터를 복사해준 뒤 이용하자!
v.erase(unique(v.begin(), v.end()),v.end());

//결과값 : v[4]={1,3,4,5}
```

# lower_bound
- 이진탐색으로 원소 탐색.
- 찾으려는 key값보다 같거나 큰 숫자가 배열 몇 번째에서 처음 등장하는지 찾음
- 찾으려는 배열이나 벡터가 **오름차순** 정렬 되어있어야 함.
`lower_bound(처음, 끝, key)`
```jsx
int arr[6]={1,2,3,4,5,6};
cout<< lower_bound(arr, arr+6, 5) - arr;

//결과 : 4 (번째 인덱스)
```
lower_bound 반환형은 iterator여서 몇 번째 인덱스인지 알고싶으면 배열 첫 번째 주소를 빼주어야함.
벡터의 경우 v.begin() 빼주면 됨.

# upper_bound
- 이진탐색으로 원소 탐색.
- 찾으려는 key을 초과하는 숫자가 배열 몇 번째에서 처음 등장하는지 찾음
- 찾으려는 배열이나 벡터가 **오름차순** 정렬 되어있어야 함.
`upper_bound(처음, 끝, key)`
```jsx
int arr[6]={1,2,3,4,5,6};
cout<< upper_bound(arr, arr+6, 3) - arr;

//결과 : 3 (번째 인덱스)
```
lower_bound와 마찬가지로 반환형이 iterator여서 몇 번째 인덱스인지 알고싶으면 배열 첫 번째 주소를 빼주어야함.
벡터의 경우 v.begin() 빼주면 됨.
